---
layout: post
title: "Using GitLab to Automate Quarkus Processes"
date: 2021-10-23
tags: user-story, development-tips, gitlab
synopsis: "Embracing Quarkus has changed how our developers work and existing processes, especially CI/CD, were re-architected as well to provide a smoother developer experience. Using GitLab, automated workflows now play a crucial role in every step of our pipeline. From inception, through development, and finally deployment, everything is managed with as little friction and as much visibility as possible."
author: kjq
---

:imagesdir: /assets/images/posts/quarkus-user-stories/logicdrop

= Using GitLab to Automate Quarkus Processes

image::logicdrop.png[Logicdrop logo,align="center"]

https://logicdrop.com[Logicdrop^] provides a business automation and data intelligence platform that enables enterprises to design their own solutions and run them in the cloud. We process millions of transactions a month across a global client-base and add significant value to mission-critical processes.  

== The Challenge
Coming from a spring boot background with multiple microservices, we had what was a pretty standard practice: Each application had it's own codebase and a copy/paste copy of a basic gitlab-ci.  Each application would live and die on it's own throughout the entire build/test/deploy process.  Granted, the gitlab-ci script was templated, but overall, each application was different enough that it couldn't be a complete copy.  Each production deploy would update the version so ordering the projects was important: Child deploys had to wait until the parent was done since the dependencies would update and that led us to only being able to deploy a single application at a time.

This took time for each full build.  Application A would be updated, tests would be run, deploy created and released, then application B would be updated with a new version for application A, tests run for application B, deploy created.....  On a good day, it would take a couple hours to go through all application waiting for the build to complete and released.  Most of this was waiting for tests to run or the release to be created which meant it was multiple 5-10 minute long waits before the next step.  There was no one button press to do everything.  Additional was the concern that a change to application A didn't break application E down the chain.

== Project Setup
We start out with creating a cluster project to specifically handle the deployments and either mono repositories or single-service repositories for the Quarkus services.

image::gitlab/cluster-project.png[GitLab Cluster Project,align="center",width="292"]
image::gitlab/templates-project.png[GitLab Templates Project,align="center",width="292"]

We mostly use a MonoRepository approach to **group** related services together... 

image::gitlab/mono-repo.png[GitLab MonoRepository Project,align="center",width="292"]

But also support a per-service approach when only a single service exists.

image::gitlab/per-service-repo.png[GitLab Per-Service Project,align="center",width="292"]

== Merge Requests and Review Environments
Talk about MR and how they create isolated environments

What gets included:
- functional tests 
- integration tests (mongo, redis)
- e2e tests (aws, external providers)
- coverage
- jacoco (the quarkus extension)
- swagger

Everything starts from a ticket and eventually becomes a merge request.

image::gitlab/merge-request.png[GitLab Merge Request,align="center"]

image::gitlab/develop-pipeline.png[GitLab Review Pipeline,align="center"]

image::gitlab/develop-downstream.png[GitLab Service Downstream Service,align="center"]
image::gitlab/cluster-downstream.png[GitLab Cluster Downstream Service,align="center"]

image::gitlab/develop-dag.png[GitLab Review DAG,align="center"]

== Promoting Services and Releases
Talk about how an MR is merged, releases are automatically created, and deployment to staging happens in one step.

Talk about how we maintain the "manifests" in S3 to allow for easier management of the cluster across multiple services, not always in a single project.

Talk about the release process which creates the tag, changelog.

image::gitlab/release-pipeline.png[GitLab Release Pipeline,align="center"]

image::gitlab/release-dag.png[GitLab Release DAG,align="center"]

== Monitoring and Visibility
Talk about integrations that keep everything in one place - logs, tracing, sentry.  All without having to leave GL.

Show pod deployments image

Also worthwhile to show the "GL" metrics recorded.

image::gitlab/view-pods.png[GitLab Pods View,align="center"]

image::gitlab/view-logs.png[GitLab Logs View,align="center"]

image::gitlab/view-sentry.png[GitLab Sentry Metrics,align="center"]

image::gitlab/view-jaeger1.png[GitLab Jaeger Metrics,align="center"]

image::gitlab/view-jaeger2.png[GitLab Jaeger Metrics,align="center"]

== Conclusion


