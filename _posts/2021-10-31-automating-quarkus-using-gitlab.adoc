---
layout: post
title: "Automating Quarkus Development with GitLab"
date: 2021-10-23
tags: user-story, development-tips, gitlab
synopsis: "Embracing Quarkus has changed how our developers work and existing processes, especially CI/CD, have been re-architected as well to provide a smoother developer experience. Using GitLab, automated workflows now play a crucial role in every step of our pipeline. From inception, through development, and finally deployment, everything is managed with as little friction and as much visibility as possible."
author: kjq
---

:imagesdir: /assets/images/posts/quarkus-user-stories/logicdrop

= Automating Quarkus Development with GitLab

image::logicdrop.png[Logicdrop logo,align="center"]

https://logicdrop.com[Logicdrop^] provides a business automation and data intelligence platform that enables enterprises to design their own solutions and run them in the cloud. We process millions of transactions a month across a global client-base and add significant value to mission-critical processes.  

== The Challenge
Coming from a spring boot background with multiple microservices, we had what was a pretty standard practice: Each application had it's own codebase and a copy/paste copy of a basic gitlab-ci.  Each application would live and die on it's own throughout the entire build/test/deploy process.  Granted, the gitlab-ci script was templated, but overall, each application was different enough that it couldn't be a complete copy.  Each production deploy would update the version so ordering the projects was important: Child deploys had to wait until the parent was done since the dependencies would update and that led us to only being able to deploy a single application at a time.

This took time for each full build.  Application A would be updated, tests would be run, deploy created and released, then application B would be updated with a new version for application A, tests run for application B, deploy created.....  On a good day, it would take a couple hours to go through all application waiting for the build to complete and released.  Most of this was waiting for tests to run or the release to be created which meant it was multiple 5-10 minute long waits before the next step.  There was no one button press to do everything.  Additional was the concern that a change to application A didn't break application E down the chain.

== GitLab Setup
The structure we settled on, for our various Quarkus services and GitLab projects, separates services, cluster operations, and templates into individual projects. This allows us to introduce changes to existing configurations or apply new ones with minimal effort and maximum flexibility.

The _cluster_ project centralizes all of our cluster pipelines and orchestrates the Quarkus service deployments using downstream triggers. It is setup as a cluster managed project in GitLab so that we manage more general cluster services, such as Helm charts deployments too.

image::gitlab/cluster-project.png[GitLab Cluster Project,align="center",width="292"]

The _templates_ project contains the various building blocks (templates) used to support end-to-end building, testing, and deployment of Quarkus services as well as other stacks. It serves as the foundation in which all other projects are built on top of.

image::gitlab/templates-project.png[GitLab Templates Project,align="center",width="292"]

=== Quarkus Services
Quarkus services can be structured either as a MonoRepository, when we can group similar services together, or more traditional per-service repositories.

TIP: By templatizing the Quarkus service pipeline specifically, we can mix and match respository styles and still maintain a consistent workflow. One consideration is to create your templates so they are flexibile enough to configure where the service resides, within a folder or at the root of a project. Done right you can invoke the service pipelines in parallel and speed up the pipeline.

==== MonoRepository
The _Platform_ project below is a MonoRepo. All of its services are contained under a `services` folder but the pipelines treat each of them as if they were a unique project.

image::gitlab/mono-repo.png[GitLab MonoRepository Project,align="center",width="292"]

==== Per-Service Repository
_Services_ is a sub-group of projects and shows the per-service approach. Each project is a single specific service rather than a family of services. 

image::gitlab/per-service-repo.png[GitLab Per-Service Project,align="center",width="292"]

TIP: Done right, a MonoRepository style can still be used for _per-service_ repositories.  This future-proofs having to make major changes later when you decide to add more related services to a project which in our experience happens more often than not. 

== Quarkus Extensions
Numerous Quarkus extensions are used throughout our projects and since GitLab offers hooks for many of the them out-of-the-box, exposing their functionalities to developers has been easy and straight-forward.  

The https://quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes^] and https://quarkus.io/guides/kubernetes-config[Quarkus Kubernetes Config^] extensions are the most crucial ones we rely on and they play an important role in our ecosystem.

Other Quarkus extensions used throughout the process and tied directly into GitLab are:

- https://quarkus.io/guides/tests-with-coverage[Quarkus Jacoco Extension^] provides coverage https://docs.gitlab.com/ee/ci/pipelines/settings.html#add-test-coverage-results-to-a-merge-request[results^] and https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html[reports^] for the job
- https://quarkus.io/guides/logging-sentry[Quarkus Logging Sentry Extension^] hooks into https://docs.gitlab.com/ee/operations/error_tracking.html[GitLab Error Tracking]
- https://quarkus.io/guides/smallrye-health[Quarkus SmallRye Health^] hooks into https://docs.gitlab.com/ee/operations/metrics/[GitLab Metrics^]
- https://quarkus.io/guides/openapi-swaggerui[Quarkus SmallRye OpenAPI Extension^] exposes https://docs.gitlab.com/ee/api/openapi/openapi_interactive.html[Swagger^] from within GitLab
- https://quarkus.io/guides/opentracing[Quarkus SmallRye OpenTracing Extension^] hooks into https://docs.gitlab.com/ee/operations/tracing.html[GitLab Tracing^]

In most cases, all that is needed to integrate an extensions functionality directly into GitLab is as simple as adding it to the project, configuring the properties, and then enabling the integration in GitLab.

TIP: Leveraging Quarkus extensions has added significant value to our process. Aside from centralizing the most common needs of developers, it has saved time, increased visibility, and reduced learning curves for all of our teams.

== Development Pipelines
Our development pipelines, which are comprised mostly of Quarkus-based services, rely heavily on https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html[merge-requests pipelines^] in GitLab. 

Using merge-requests we are able to provide a good amount visibility and functionality to developers in one place so that they can easily iterate and experiment in safety within the confines of a feature.

image::gitlab/merge-request.png[Merge Request,align="center"]

Within each merge-request we:

- Always run the unit tests
- Run integration tests (Mongo, Redis)
- Run E2E tests (AWS, external services)
- Generate code coverage and quality reports
- Provide interactive access to that branch's Swagger API
- Deploy one or more services into a isolated namespace

=== Merge-Request Pipeline
Merge-requests are specialized pipelines specific to the day-to-day developer process. From a merge-request, developers can work with any branch and deploy or test those services in isolation.

image::gitlab/develop-pipeline.png[Review Pipeline,align="center"]

The merge-request pipeline leverages two reusable downstream pipelines:

- Quarkus Build
- Cluster Deploy

=== Cleaning up Resources
Because we don't want cluster resources, or the merge-request, to linger out there if it is not in use anymore we use the environments `stop` action to automatically cleanup resources when a branch has been merged, deleted, or stopped.

image::gitlab/stop-environment.png[Stopping an Environment,align="center"]

If a merge-request has become stale it will automatically be stopped and cleanup the resources.

== Downstream Quarkus Build
Regardless of being in a merge-request, promoting from the default branch, or releasing a build, Quarkus services are handled through their own downstream pipeline.

For Quarkus services specifically, the following jobs are always run in a downstream job:

- Build the service, usually native, but using labels can be FastJars.
- Run any tests for the service.
- Generate the Kubernetes manifests for the service.
- Build and deploy the container to the registry.

We will reuse this pipeline whenever we need to build, test, and deploy a Quarkus service.

image::gitlab/develop-downstream.png[Service Downstream Service,align="center"]

Once the container is built the service can be deployed at anytime.

After a service has been built it can be selectively deployed into an isolated namespace in the cluster. Services that are not required get deployed using the latest staging service.

Deploying a service into the cluster triggers another downstream job responsible for the deployment.

== Downstream Cluster Deploy
When deploying to the cluster, one or more services, a single downstream job in the cluster-managed project perform these steps:

- Create and apply the namespace ConfigMap
- Create and apply the namespace Secrets
- Apply any application.yaml overrides

We will reuse this pipeline whenever we need to trigger a cluster deployment, from any service, but with different properties depending on the environment.

image::gitlab/cluster-downstream.png[Cluster Downstream Service,align="center"]

== Speeding up the Pipeline
We make heavy use of GitLabs `needs` keyword to speed up the pipelines. For example, compile and unit tests are all that is required within a merge-request to deploy the service.  Even though integration tests may be running, once the compile job finishes you can immediately deploy the service into the cluster.

The DAG shows how we short-circuit longer-running jobs so that other jobs can be started quicker, further speeding up the process.

image::gitlab/develop-dag.png[Review DAG,align="center"]

== Promoting Releases
Once a merge-request has been approved and gets merged into the default branch you are now ready to promote it.  Promotion, for us, is the process of formally creating a release that can be deployed to higher environments like staging or production.

Where a branch drives the development process, a tag drives the release process.

image::gitlab/promotion.png[Promoting a Release,align="center"]

Running the `promote` job will perform the following actions:

- Create a tag based off of the current Maven version.
- Create a release from the tag.
- Update the changelog of the project.
- Build and deploy the selected services.
- Bump the version to the next version.

You can see the transitioning from a merge-request, to merging into the default branch, and finally promotion in the jobs pictured below.

image::gitlab/transition.png[Transition to a Release,align="center"]

Once the tag has been created the release pipeline runs and by default builds and deploys each of the Quarkus services to the next environment.

Services are built in parallel to help speed up the process.

image::gitlab/release-pipeline.png[Deploy to Staging,align="center"]

Finally, a formal release is created automically, deployed to a Nexus repository, and then bumped to the next `SNAPSHOT` version.

image::gitlab/release.png[Created Release,align="center"]

Each merged branch increments the patch version by default unless a label of `minor` or `major` is applied to the merge-request. This automates the Maven release process (we use the Maven Deploy and Flatten plugin with the CI-friendly approach) without manual intervention.

== One Deploy
By leveraging AWS S3 rather than GitLabs own artifact storage we can deploy one or more services at any given time to the cluster.  We can also track these versions, any artifacts that go along with them, and rollback easily.

image::gitlab/deployment.png[Single Deployment,align="center"]

Because deployments into higher environments are controlled by a single downstream cluster job we can easily see what version is currently deployed and rollback to another version if needed.

image::gitlab/history.png[History of Deployments,align="center"]

== Monitoring and Visibility
The end result of tightly integrating GitLab with our Quarkus platform is that not only has our process become greatly streamlined but we also are able to provide a one-stop-shop for most of the relevant tools, logs, and monitoring in one place.  

By centralizing the most common needs, we have increased overall developer productivity and made it easier to navigate what is usually a confusing landscape when building a microservice architecture.

What makes our process unique is that everything below is accessible using GitLab only...

Teams can use GitLab for a majority of what they usually need to do and do not need interact with external tools and applications except in advanced scenarios.

=== Test Endpoints
Swagger can be viewed and invoked within each merge-request. This allows for quick and easy spot testing during the development lifecycle.

image::gitlab/swagger.png[Swagger API,align="center"]

=== See Errors and Warnings
Sentry is hooked into each project so that we can see specific errors and warnings quickly and easily.  We can even create or resolve tickets directly from the issue.  

image::gitlab/view-sentry.png[Sentry Errors,align="center"]

=== Generate Coverage and Quality Reports
Jacoco generates coverage reports for each project and all the services within it when branches are merged. Coverage metrics are maintained and compare throughout the lifetime of each project.

image::gitlab/coverage.png[Coverage Report,align="center"]

Additionally, Code Climate is used to show changes in quality from the default branch and each merge request throughout the life of every project.

=== Analyze Distributed Services
Jaeger provides us with insights into how services are being used and gives us the ability to trace execution across multiple services.

image::gitlab/view-jaeger1.png[Jaeger Query,align="center"]
image::gitlab/view-jaeger2.png[Jaeger Details,align="center"]

This is especially important in our platform because we heavily rely on single-responsibility services that need to communicate with other services and compose functionalities.

=== Monitor Pod Health
Pod health can be monitored, per environment, by adding a couple of GitLab-specific annotations to the Quarkus generated Kubernetes manifests.

image::gitlab/view-pods.png[Pod Health,align="center"]

=== Review Cluster Logs
Kubernetes logs can be viewed, for any of the pods, through the cluster-managed project alleviating the need for direct access to the cluster. 

Logs can be viewed per environment or filtered for specific pods.

image::gitlab/view-logs.png[Cluster Logs,align="center"]

=== Collect Prometheus Metrics
Prometheus metrics are exposed using GitLab's monitoring and metrics. 

image::gitlab/prom.png[Prometheus Metrics,align="center"]

We even have the ability to hook in custom Granfana dashboards.

== Conclusion


