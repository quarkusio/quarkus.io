---
layout: post
title: "Using GitLab to Automate Quarkus Processes"
date: 2021-10-23
tags: user-story, development-tips, gitlab
synopsis: "Embracing Quarkus has changed how our developers work and existing processes, especially CI/CD, were re-architected as well to provide a smoother developer experience. Using GitLab, automated workflows now play a crucial role in every step of our pipeline. From inception, through development, and finally deployment, everything is managed with as little friction and as much visibility as possible."
author: kjq
---

:imagesdir: /assets/images/posts/quarkus-user-stories/logicdrop

= Using GitLab to Automate Quarkus Processes

image::logicdrop.png[Logicdrop logo,align="center"]

https://logicdrop.com[Logicdrop^] provides a business automation and data intelligence platform that enables enterprises to design their own solutions and run them in the cloud. We process millions of transactions a month across a global client-base and add significant value to mission-critical processes.  

== The Challenge
Coming from a spring boot background with multiple microservices, we had what was a pretty standard practice: Each application had it's own codebase and a copy/paste copy of a basic gitlab-ci.  Each application would live and die on it's own throughout the entire build/test/deploy process.  Granted, the gitlab-ci script was templated, but overall, each application was different enough that it couldn't be a complete copy.  Each production deploy would update the version so ordering the projects was important: Child deploys had to wait until the parent was done since the dependencies would update and that led us to only being able to deploy a single application at a time.

This took time for each full build.  Application A would be updated, tests would be run, deploy created and released, then application B would be updated with a new version for application A, tests run for application B, deploy created.....  On a good day, it would take a couple hours to go through all application waiting for the build to complete and released.  Most of this was waiting for tests to run or the release to be created which meant it was multiple 5-10 minute long waits before the next step.  There was no one button press to do everything.  Additional was the concern that a change to application A didn't break application E down the chain.

== Project Setup
We start out with creating a cluster project to specifically handle the deployments and either mono repositories or single-service repositories for the Quarkus services.

image::gitlab/cluster-project.png[GitLab Cluster Project,align="center",width="292"]
image::gitlab/templates-project.png[GitLab Templates Project,align="center",width="292"]

We mostly use a MonoRepository approach to **group** related services together... 

image::gitlab/mono-repo.png[GitLab MonoRepository Project,align="center",width="292"]

But also support a per-service approach when only a single service exists.

image::gitlab/per-service-repo.png[GitLab Per-Service Project,align="center",width="292"]

== Quarkus Extensions
Numerous Quarkus extensions are used by our GitLab process.  The main ones we rely on to control and configure the pipelines are:

- Quarkus Config YAML Extension
- Quarkus Jacoco Extension
- Quarkus Kubernetes Extension
- Quarkus Kubernetes Config Extension
- Quarkus Logging Sentry Extension
- Quarkus SmallRye Health
- Quarkus SmallRye OpenAPI Extension
- Quarkus SmallRye OpenTracing Extension

== Development Pipelines
Talk about MR and how they create isolated environments

What gets included:
- functional tests 
- integration tests (mongo, redis)
- e2e tests (aws, external providers)
- coverage
- jacoco (the quarkus extension)
- swagger

Everything starts from a ticket and eventually becomes a merge request.

image::gitlab/merge-request.png[Merge Request,align="center"]

image::gitlab/develop-pipeline.png[Review Pipeline,align="center"]

image::gitlab/develop-downstream.png[Service Downstream Service,align="center"]
image::gitlab/cluster-downstream.png[Cluster Downstream Service,align="center"]

The DAG shows how we short-circuit longer-running jobs so that other jobs can be started quicker, further speeding up the process.

image::gitlab/develop-dag.png[Review DAG,align="center"]

Accepting a merge-request automatically stops the environment and cleans up the cluster resources.  If a merge-request has not been touched for a period of time it will automatically cleanup the resources.

image::gitlab/stop-environment.png[Stopping an Environment,align="center"]

== Release Pipelines
Promotion into higher environments, staging or production, starts off when one or more merge-requests have been merged into the default branch.

From the main branch, you can choose to promote when you are ready.  Promoting creates a release tag which starts the deployment into higher environments.

image::gitlab/promotion.png[Promoting a Release,align="center"]

When a release tag is created the services will automatically be versioned and deployed into staging.

image::gitlab/release-pipeline.png[Deploy to Staging,align="center"]

image::gitlab/release.png[Created Release,align="center"]

== One Deploy
Rolling up the services, talk about S3 and latest, allows us to better control and track deployments regardless of artifacts.

image::gitlab/deployment.png[Single Deployment,align="center"]

image::gitlab/history.png[History of Deployments,align="center"]

== Monitoring and Visibility
The end result of tightly integrating GitLab with our Quarkus platform is that not only has our process become greatly streamlined but we also are able to provide a one-stop-shop for most of the relevant tools, logs, and monitoring in one place.  

By centralizing the most common needs, we have increased overall developer productivity and made it easier to navigate what is usually a confusing landscape when building a microservice architecture.

What makes our process unique is that everything below is accessible using GitLab only...

Teams can use GitLab for a majority of what they usually need to do and do not need interact with external tools and applications except in advanced scenarios.

=== Test Endpoints
Swagger can be viewed and invoked within each merge-request. This allows for quick and easy spot testing during the development lifecycle.

image::gitlab/swagger.png[Swagger API,align="center"]

=== See Errors and Warnings
Sentry is hooked into each project so that we can see specific errors and warnings quickly and easily.  We can even create or resolve tickets directly from the issue.  

image::gitlab/view-sentry.png[Sentry Errors,align="center"]

=== Generate Coverage and Quality Reports
Jacoco generates coverage reports for each project and all the services within it when branches are merged. Coverage metrics are maintained and compare throughout the lifetime of each project.

image::gitlab/coverage.png[Coverage Report,align="center"]

Additionally, Code Climate is used to show changes in quality from the default branch and each merge request throughout the life of every project.

=== Trace and Monitor Distributed Services
Jaeger provides us with insights into how services are being used and gives us the ability to trace execution across multiple services.

image::gitlab/view-jaeger1.png[Jaeger Query,align="center"]
image::gitlab/view-jaeger2.png[Jaeger Details,align="center"]

=== Monitor Pod Health
Pod health can be monitored, per environment, by adding a couple of GitLab-specific annotations to the Quarkus generated Kubernetes manifests.

image::gitlab/view-pods.png[Pod Health,align="center"]

=== Review Cluster Logs
Kubernetes logs can be viewed, for any of the pods, through the cluster-managed project alleviating the need for direct access to the cluster. 

Logs can be viewed per environment or filtered for specific pods.

image::gitlab/view-logs.png[Cluster Logs,align="center"]

=== Collect Prometheus Metrics
Prometheus metrics are exposed using GitLab's monitoring and metrics. 

image::gitlab/prom.png[Prometheus Metrics,align="center"]

We even have the ability to hook in custom Granfana dashboards.

== Conclusion


