---
layout: post
title: "Automating Quarkus Development with GitLab"
date: 2021-10-23
tags: user-story, development-tips, gitlab
synopsis: "Embracing Quarkus has changed how our developers work and existing processes, especially CI/CD, have been re-architected to provide a more integrated experience. Every step, from inception, to development through deployment, and finally monitoring, is orchestrated using GitLab."
author: kjq
---

:imagesdir: /assets/images/posts/quarkus-user-stories/logicdrop

= Automating Quarkus Development with GitLab

image::logicdrop.png[Logicdrop logo,align="center"]

https://logicdrop.com[Logicdrop^] provides a business automation and data intelligence platform that enables enterprises to design their own solutions and run them in the cloud. We process millions of transactions a month across a global client-base and add significant value to mission-critical processes.  

== The Challenge
Since moving to https://quarkus.io/[Quarkus^], our productivity quickly started to outpace our CI/CD process. We needed a better way to leverage microservices and cloud-native approaches, deploy faster and more frequently, and finally involve everyone throughout the entire process.

We came to the conclusion that the complexity was not in deployments, we could always get our services deployed, but the real challenge was how to orchestrate efforts up to deployment and beyond.

Some of the challenges we faced were:

- Environments got more complicated with more services
- Debugging distributed services was challenging
- Different toolsets were needed, and used, for visibility
- No isolated way to develop or share work, except locally
- Collaboration between front and back-end teams was lacking

_There had to be a better way..._

This is our evolving blueprint of how we leverage https://quarkus.io/[Quarkus^], especially the extensions, with https://about.gitlab.com/[GitLab^] and tie everything together into a cohesive ecosystem accessible by everyone.

== GitLab Projects
The structure we settled on was to split cluster operations, templates, and Quarkus services into individual projects.  This allows us to easily introduce changes to existing configurations or apply new ones with minimal effort and maximum flexibility.

The *cluster* project centralizes anything touching the Kubernetes cluster. It is configured as a GitLab https://docs.gitlab.com/ee/user/clusters/management_project_template.html[cluster-management^] project so we can include managing other cluster-wide services like Elastic, Nginx, or other Helm charts.

The *templates* project contains all the building blocks used by our GitLab projects. It makes maintenance easier, provides flexibility, and promotes consistency.  Developers can onboard new services, in less than a few minutes, using these templates.

image::gitlab/layers.png[Cluster-Templates-Services,align="center"]

*Quarkus projects* are structured as a _family of services_ each individually worked on and deployed. Each service uses triggers to notify the cluster when its ready to be deployed or cleaned up.

TIP: We found using https://quarkus.io/guides/config-yaml#profiles[Quarkus profiles^] and abstracting common release and Kubernetes properties into a shared JAR shielded developers even more from having to manage individual configurations.

Using Quarkus we elminated having to maintain Helm charts for the services. We even have Quarkus services that interact directly with GitLab for specific tooling and metrics we maintain.

== Quarkus Extensions
Using out-of-box https://quarkus.io/guides/[Quarkus extensions^] made it straight-forward to quickly expose a wide range of logs, metrics, and functionality.

Leveraging the extensions _and_ integrating them into GitLab has:

- Saved time
- Reduced efforts
- Increased visibility
- Fostered collaboration
- Minimized complexity

The most important extensions we use are the https://quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes^] and https://quarkus.io/guides/kubernetes-config[Quarkus Kubernetes Config^] extensions. 

Other extensions we integrate into GitLab are:

- https://quarkus.io/guides/tests-with-coverage[Quarkus Jacoco^] for coverage https://docs.gitlab.com/ee/ci/pipelines/settings.html#add-test-coverage-results-to-a-merge-request[results^] and https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html[reports^]
- https://quarkus.io/guides/logging-sentry[Quarkus Logging Sentry^] hooks into https://docs.gitlab.com/ee/operations/error_tracking.html[GitLab Error Tracking^]
- https://quarkus.io/guides/smallrye-health[Quarkus SmallRye Health^] hooks into https://docs.gitlab.com/ee/operations/metrics/[GitLab Metrics^]
- https://quarkus.io/guides/openapi-swaggerui[Quarkus SmallRye OpenAPI^] exposes the https://docs.gitlab.com/ee/api/openapi/openapi_interactive.html[Swagger API^]
- https://quarkus.io/guides/opentracing[Quarkus SmallRye OpenTracing^] hooks into https://docs.gitlab.com/ee/operations/tracing.html[GitLab Tracing^]

Weaving Quarkus extensions together we are able to get a complete picture of our environments, from development to deployment and monitoring, this has made building and supporting microservices easier. 

== Dreaming of Pipelines

=== Developer Powered Deployments
In rethinking our development process from the ground-up for a cloud-native world we wanted to simplify the developer/deploy process. 

Previously, deployments to higher environments was tedious but doable. Developers were not involved in this process. 

TIP: Since moving to Quarkus, developers are now responsible for developing _and_ deploying (limitations apply). 

In GitLab, we settled on https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html[merge requests pipelines^] to be the catalyst that drove our process.

image::gitlab/merge-request.png[Merge Request,align="center"]

On every push, a merge request will:

- Run all the unit tests
- Run any integration tests (Mongo, AWS, Redis)
- Run any E2E tests (other external services)
- Generate code coverage and quality reports
- Publish an interactive Swagger API

*The most useful feature of the merge request is that we can deploy any number of services, and interact with them, into isolated environments.*

image::gitlab/develop-pipeline.png[Review Pipeline,align="center"]

_Preview_ services lets us go beyond automated testing. We can spot-test only what is being worked on or even run the full suite of services if needed (this is especially useful during a combined UX and multiple service feature).

TIP: Lighter than a feather, Quarkus native images are 1/10th the size of their comparable pure Java counterparts. This allows us to deploy a full set of services in less space then it would take to deploy the equivalent Spring-Boot services.

=== Building Quarkus Services
The downstream Quarkus pipeline is a specialized set of jobs that handle building, testing, and containerizing Quarkus services only.

For each service that has changed we:

- Build the native image or FastJar
- Run any tests (including native ones if needed)
- Generate the Kubernetes manifests
- Build and deploy its container

image::gitlab/develop-downstream.png[Service Downstream Service,align="center"]

TIP: We _only_ push the container and upload the manifests to AWS S3. This lets us accumulate, over time if needed, all changes into a single package that can be deployed when needed. 

=== Faster Faster Pipelines
To speed up the pipelines, especially when building multiple native services, we rely on GitLab AutoScaling runners to run the jobs in parallel.  This allows us to build any number of services in a relatively constant time frame.

TIP: Currently, for 20+ services, we can perform complete end-to-end deployments, including native builds, in less than 20 minutes without manual intervention. Most of the time we are only deploying changed services so the net time is far less.

We use the GitLab's https://docs.gitlab.com/ee/ci/yaml/#needs[`needs`^] keyword to short-circuit the pipelines so we can get to more important jobs without waiting, allowing us to immediately, and repeatedly if needed, deploy services as they are ready.

image::gitlab/develop-dag.png[Review DAG,align="center"]

In the above https://docs.gitlab.com/ee/ci/directed_acyclic_graph/[DAG^], once a service is ready we can deploy it without having to wait for other jobs to finish.

TIP: Native builds are intensive, it is best to run them in parallel. Mileage may vary but we found AWS M5.XL instances to be the best value for our money when doing this.

== One Deploy to Rule Them All
Where a branch drives the development process, a tag drives the release process. 

At any given time the default branch can be promoted with a single click. This initiates a series of jobs that finally _deploy the updated services into our cluster without manual intervention_.

Unless a test fails (which should of been caught before-hand), the pipeline, whether it comes from a developer branch or the default branch is _fully automated_.

image::gitlab/promotion.png[Promoting a Release,align="center"]

Clicking `promote` starts out by performing these steps:

- Reconcile Maven versions
- Update the changelog
- Create the release tag
- Build service(s) and deploy the containers
- Generate the Kubernetes manifests
- Publish Swagger API and generate OpenAPI clients
- Bumping the version to the next version

TIP: For better or worse, we do use https://maven.apache.org/maven-ci-friendly.html[Maven CI Friendly^] versions to help us simplify our versioning and deployment.

Below, multiple jobs all running at the same time, including every building ever Quarkus service in the project.

image::gitlab/release-pipeline.png[Deploy to Staging,align="center"]

As the service builds complete, the deployment to the next environment begins automatically.

image::gitlab/deployment.png[Single Deployment,align="center"]

A triggered downstream cluster job then pulls down the Kubernetes manifests, performs any environment specific configurations, and finally deploys the service(s).

image::gitlab/cluster-downstream.png[Cluster Downstream Service,align="center"]

You can see the transition of pipelines from a merge request, to being merged, and finally being released below.

image::gitlab/transition.png[Transitions of Pipelines,align="center"]

== Git Your Quarkus Features
By tightly integrating our GitLab process with our Quarkus platform, our process has been trimmed down and it provides a one-stop shop for tools, logs, and monitoring. The most significant benefit is that everything can be accessed right from GitLab...

Teams can use GitLab first instead of having to interact with different external tools and applications (except in advanced scenarios).

=== Interactive API Endpoints
Swagger can be viewed and interacted with directly in GitLab. This allows for quick and easy spot testing during development or validating endpoints post-deployment.

image::gitlab/swagger.png[Swagger API,align="center"]

=== Errors and Warnings
Sentry is hooked into each project so that specific errors and warnings can be found quickly and easily without having to dig through logs. GitLab can even create or resolve tickets directly from the Sentry issue.  

image::gitlab/view-sentry.png[Sentry Errors,align="center"]

=== Coverage and Quality Reports
Jacoco generates coverage reports for each project and all the services within it. Metrics are maintained and visible throughout the lifetime of each service.

image::gitlab/coverage.png[Coverage Report,align="center"]

Additionally, Code Climate is used to measure changes in quality between the default branch and each merge request throughout the lifetime of every service.

=== Distributed Service Traces
Jaeger provides us with insights into how our APIs are used and lets us trace interactions between multiple services.

image::gitlab/view-jaeger1.png[Jaeger Query,align="center"]
image::gitlab/view-jaeger2.png[Jaeger Details,align="center"]

This is especially important in our platform because we heavily rely on single-responsibility services that communicate with other services.

=== Dependency Changes
Dependabot is wired in to let us know when there are changes to any dependencies.  This is especially useful when one of our own dependencies gets released and other projects need to made aware of it. 

image::gitlab/dependabot.png[Dependabot,align="center"]

=== Environments and Pod Health
Every environment is monitored and you can see what pods are active in them by adding a couple of GitLab-specific annotations to the Quarkus Kubernetes configuration.

image::gitlab/view-pods.png[Pod Health,align="center"]

=== Cluster Logs
Kubernetes logs can be viewed right from GitLab, eliminating the need for access to the cluster by developers. 

Logs can be viewed per environment or filtered for specific pods.

image::gitlab/view-logs.png[Cluster Logs,align="center"]

=== Prometheus Metrics
Prometheus metrics are exposed using GitLab's monitoring and metrics. 

image::gitlab/prom.png[Prometheus Metrics,align="center"]

== Conclusion
Integrating Quarkus deeply into GitLab has added significant value to our process and was well worth the little effort it took. 

Building upon our _level the playing field_ philosophy, developing, debugging, deploying, and monitoring a large cloud-native platform is now more streamlined than ever.

Because of the natural fit Quarkus has with cloud technologies, and the functionality provided through extensions, we have been able to create a full DevOps ecosystem that normally would be challenging to setup and orchestrate.

Some of the highlights are:

- Developers can work with services in isolation
- Configurations are fully automated
- Parallizing builds decreased the time to deliver changes
- Deployments are completely automated
- Common tools are made available within GitLab

At the end of the day, we do not have to train staff in different tools, grant access any further then GitLab, or expose any infrastructure directly. 

This new process, while it may seem intensive, is completely automated end-to-end and requires little to no manual intervention.

Most of the functionality we need, at least initially, is accessible from one place - this lets us iterate, collaborate, and react quicker.



