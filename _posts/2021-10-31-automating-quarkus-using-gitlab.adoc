---
layout: post
title: "Automating Quarkus Development with GitLab"
date: 2021-10-23
tags: user-story, development-tips, gitlab
synopsis: "Embracing Quarkus has changed how our developers work and existing processes, especially CI/CD, have been re-architected as well to provide a smoother developer experience. Using GitLab, automated workflows now play a crucial role in every step of our pipeline. From inception, through development, and finally deployment, everything is managed with as little friction and as much visibility as possible."
author: kjq
---

:imagesdir: /assets/images/posts/quarkus-user-stories/logicdrop

= Automating Quarkus Development with GitLab

image::logicdrop.png[Logicdrop logo,align="center"]

https://logicdrop.com[Logicdrop^] provides a business automation and data intelligence platform that enables enterprises to design their own solutions and run them in the cloud. We process millions of transactions a month across a global client-base and add significant value to mission-critical processes.  

== The Challenge
Coming from a spring boot background with multiple microservices, we had what was a pretty standard practice: Each application had it's own codebase and a copy/paste copy of a basic gitlab-ci.  Each application would live and die on it's own throughout the entire build/test/deploy process.  Granted, the gitlab-ci script was templated, but overall, each application was different enough that it couldn't be a complete copy.  Each production deploy would update the version so ordering the projects was important: Child deploys had to wait until the parent was done since the dependencies would update and that led us to only being able to deploy a single application at a time.

This took time for each full build.  Application A would be updated, tests would be run, deploy created and released, then application B would be updated with a new version for application A, tests run for application B, deploy created.....  On a good day, it would take a couple hours to go through all application waiting for the build to complete and released.  Most of this was waiting for tests to run or the release to be created which meant it was multiple 5-10 minute long waits before the next step.  There was no one button press to do everything.  Additional was the concern that a change to application A didn't break application E down the chain.

== GitLab Setup
The setup we settled on for everything was to split services, cluster operations, and templates into individual projects.  This allows us to easily introduce changes to existing configurations or apply new ones with minimal effort and maximum flexibility.

The _cluster_ project consolidates our cluster operations by centralizing anything that touches the kubernetes cluster into a single application. Each Quarkus service uses downstream triggers to notify the cluster project when something needs to be deployed or cleaned up.  

It is configured as a GitLab https://docs.gitlab.com/ee/user/clusters/management_project_template.html[cluster-management^] project to manage standard cluster applications like elastic, Nginx, or Jaeger, and any additional custom Helm charts.

image::gitlab/cluster-project.png[GitLab Cluster Project,align="center",width="292"]

The _templates_ project contains the various building blocks used by all GitLab jobs which allows easy maintainence and flexability.  Each Quarkus service reuses these templates resulting the Gitlab-ci scripts being very small.
  
image::gitlab/templates-project.png[GitLab Templates Project,align="center",width="292"]

=== Quarkus Services
Why Quarkus? Using Quarkus elminates using Helm charts to build the Kubernetes configuration. Each service is capable of creating its own manifests using the https://quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes^] and https://quarkus.io/guides/kubernetes-config[Quarkus Kubernetes Config^] extensions.

TIP: Watch the service name carefully if you care overriding the Quarkus template.  It must match exactly or it will cause duplicates.

The _Platform_ project below is an example Mono Repository. All of its services are contained under a `services` folder but the pipelines treat each of them as if they were a unique project.

image::gitlab/mono-repo.png[GitLab Mono Repository Project,align="center",width="292"]

== Quarkus Extensions
Using out-of-box https://quarkus.io/guides/[Quarkus extensions^] has made it easy and straight-forward to centralize the most common needs of developers in one place. 

Leveraging the extensions _and_ integrating them into GitLab has:

- Saved time
- Increased visibility
- Fostered collaboration
- Reduced complexity

Two of the most important extensions we use are the https://quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes^] and https://quarkus.io/guides/kubernetes-config[Quarkus Kubernetes Config^] extensions. 

TIP: We found using https://quarkus.io/guides/config-yaml#profiles[Quarkus profiles^] and abstracting common release and Kubernetes properties into a shared JAR shielded developers even more from having to manage individual configurations.

Other useful extensions we integrate into GitLab are:

- https://quarkus.io/guides/tests-with-coverage[Quarkus Jacoco Extension^] for coverage https://docs.gitlab.com/ee/ci/pipelines/settings.html#add-test-coverage-results-to-a-merge-request[results^] and https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html[reports^]
- https://quarkus.io/guides/logging-sentry[Quarkus Logging Sentry Extension^] hooks into https://docs.gitlab.com/ee/operations/error_tracking.html[GitLab Error Tracking^]
- https://quarkus.io/guides/smallrye-health[Quarkus SmallRye Health^] hooks into https://docs.gitlab.com/ee/operations/metrics/[GitLab Metrics^]
- https://quarkus.io/guides/openapi-swaggerui[Quarkus SmallRye OpenAPI Extension^] exposes https://docs.gitlab.com/ee/api/openapi/openapi_interactive.html[Swagger^] from within GitLab
- https://quarkus.io/guides/opentracing[Quarkus SmallRye OpenTracing Extension^] hooks into https://docs.gitlab.com/ee/operations/tracing.html[GitLab Tracing^]

TIP: Quarkus extensions are what make the whole process so powerful. They are easy enough to setup and add value by themselves but, when made an integral part of the developer experience, their simplicity and flexibility really start to shine. We found by weaving extensions together we can get a complete picture of our environment, from development to deployment and beyond, and it has made developing and debugging microservices easier.

== Dreaming of Pipelines

=== Developer Powered Deployments
In rethinking our development process from the ground-up for a cloud-native world we wanted to simplify the developer/deploy process. 

TIP: Previously, deployments to higher environments was tedious but doable by our Ops team on request. Developers were not involved in this process. Since moving to Quarkus, developers are now responsible for developing _and_ deploying (limitations apply). 

Using GitLab, we focused on using https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html[merge requests pipelines^] as the catalyst to drive our development process.

image::gitlab/merge-request.png[Merge Request,align="center"]

Within every merge request we:

- Run all the unit tests
- Run integration tests (Mongo, AWS, Redis)
- Run E2E tests (other external services)
- Generate code coverage and quality reports
- Provide live interaction with that branch's Swagger API

Most importantly, each merge request can deploy any number of services which can interacted with in their own isolated environment. 

Developers can go beyond just automated testing and do anything from a spot-testing a single service to running a full suite of services if needed (especially useful during a combined UX and Service feature).

image::gitlab/develop-pipeline.png[Review Pipeline,align="center"]

TIP: Lighter than a feather, Quarkus Native Builds are 1/10th the size of their comparable pure Java counterparts. This allows us to deploy a full set of services, if needed, in the space it would typically take to deploy the equivalent Spring-Boot services.

Two important parts of our pipeline are the downstream jobs that handle Quarkus services and then deploy them.

=== Building Quarkus Services
The downstream Quarkus build is a unique pipeline specific to building, testing, and containerizing (only) just Quarkus services. 

For each changed service we:

- Build the executable - native or FastJar
- Run any tests
- Generate Kubernetes manifests
- Build and deploy its container

image::gitlab/develop-downstream.png[Service Downstream Service,align="center"]

Once a container has been built and the manifests uploaded, the deploy package can be referenced anytime (or we can rollback to any previous version if needed).

TIP: We _only_ push the container and upload the manifests to AWS S3. This lets us accumulate, over time if needed, any changes into a single package that can be further configured during deployment. 

=== Faster Faster Pipelines
To speed up the pipelines, especially when building multiple native services, we use GitLab AutoScaling runners to run the jobs in parallel.  This allows us to build any number of services in a relatively constant time frame of about 10-20 minutes.

We use the GitLab's https://docs.gitlab.com/ee/ci/yaml/#needs[`needs`^] keyword to short-circuit pipelines so that we can get to more important jobs quicker.  This allows us to immediately, and repeatedly if needed, deploy services as they are ready instead of having to wait for other jobs to finish.

image::gitlab/develop-dag.png[Review DAG,align="center"]

In the above https://docs.gitlab.com/ee/ci/directed_acyclic_graph/[DAG^], anytime any service is ready we can deploy it without having to wait for other jobs.

TIP: Native builds are intensive, it is best to run them in parallel. Mileage may vary but We found AWS M5.XL instances to be the best value for our money when building native services.

== One Deploy to Rule Them All
Where a branch drives the development process, a tag drives the release process. 

At any given time the default branch can be promoted with a single click. This initiates a series of jobs that eventually _deploy only the updated services into our cluster without manual intervention_.

What makes this so phenomenal, is that unless a test fails (which should of be caught before-hand based on our process), the whole promotion to deployment, whether it comes from a developer branch or the default branch is _fully automated_.

image::gitlab/promotion.png[Promoting a Release,align="center"]

Clicking `promote` starts out by performing these steps:

- Reconcile Maven versions
- Update the changelog
- Create the release tag
- Build service(s) and deploy the containers
- Generate the Kubernetes manifests
- Publish Swagger API and generate OpenAPI clients
- Bumping the version to the next version

TIP: For better or worse, we do use https://maven.apache.org/maven-ci-friendly.html[Maven CI Friendly^] versions to help us simplify our versioning and deployment.

Here we see the multiple jobs all running at the same time, including every Quarkus service pipeline in the project.

image::gitlab/release-pipeline.png[Deploy to Staging,align="center"]

Once the service builds are completed, the deployment to the next environment begins automatically.

image::gitlab/deployment.png[Single Deployment,align="center"]

The triggered downstream cluster job pulls down the generated manifests, performs any environment specific configurations, then finally deploys the service(s).

image::gitlab/cluster-downstream.png[Cluster Downstream Service,align="center"]

You can see the transition from a merge request, to being merged, and then finally being released below.

image::gitlab/transition.png[Transitions of Pipelines,align="center"]

TIP: Currently, for 20+ services, we can perform complete end-to-end deployments, including native builds, in less than 20 minutes without any manual intervention. Most of the time we are only deploying changed services and the net time is far less.

== Git Your Quarkus Features
By tightly integrating our GitLab process with our Quarkus platform, our process has been trimmed down and it provides a one-stop shop for tools, logs, and monitoring. The most significant benefit is that everything can be accessed right from GitLab...

Teams can use GitLab first instead of having to interact with different external tools and applications (except in advanced scenarios).

=== Interactive API Endpoints
Swagger can be viewed and interacted with directly in GitLab. This allows for quick and easy spot testing during development or validating endpoints post-deployment.

image::gitlab/swagger.png[Swagger API,align="center"]

=== Errors and Warnings
Sentry is hooked into each project so that specific errors and warnings can be found quickly and easily without having to dig through logs. GitLab can even create or resolve tickets directly from the Sentry issue.  

image::gitlab/view-sentry.png[Sentry Errors,align="center"]

=== Coverage and Quality Reports
Jacoco generates coverage reports for each project and all the services within it. Metrics are maintained and visible throughout the lifetime of each service.

image::gitlab/coverage.png[Coverage Report,align="center"]

Additionally, Code Climate is used to measure changes in quality between the default branch and each merge request throughout the lifetime of every service.

=== Distributed Service Traces
Jaeger provides us with insights into how our APIs are used and lets us trace interactions between multiple services.

image::gitlab/view-jaeger1.png[Jaeger Query,align="center"]
image::gitlab/view-jaeger2.png[Jaeger Details,align="center"]

This is especially important in our platform because we heavily rely on single-responsibility services that communicate with other services.

=== Pod Health
Pod health can be monitored, per environment, by adding a couple of GitLab-specific annotations to the Quarkus generated Kubernetes manifests. This also shows us what pods are alive at any given time.

image::gitlab/view-pods.png[Pod Health,align="center"]

=== Cluster Logs
Kubernetes logs can be viewed from GitLab, eliminating the need for access to the cluster by developers. 

Logs can be viewed per environment or filtered for specific pods.

image::gitlab/view-logs.png[Cluster Logs,align="center"]

=== Prometheus Metrics
Prometheus metrics are exposed using GitLab's monitoring and metrics. 

image::gitlab/prom.png[Prometheus Metrics,align="center"]

We even have the ability to hook in custom Granfana dashboards.

== Conclusion


