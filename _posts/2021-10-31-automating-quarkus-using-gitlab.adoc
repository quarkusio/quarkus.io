---
layout: post
title: "Automating Quarkus Development with GitLab"
date: 2021-10-23
tags: user-story, development-tips, gitlab
synopsis: "Embracing Quarkus has changed how our developers work and existing processes, especially CI/CD, have been re-architected as well to provide a smoother developer experience. Using GitLab, automated workflows now play a crucial role in every step of our pipeline. From inception, through development, and finally deployment, everything is managed with as little friction and as much visibility as possible."
author: kjq
---

:imagesdir: /assets/images/posts/quarkus-user-stories/logicdrop

= Automating Quarkus Development with GitLab

image::logicdrop.png[Logicdrop logo,align="center"]

https://logicdrop.com[Logicdrop^] provides a business automation and data intelligence platform that enables enterprises to design their own solutions and run them in the cloud. We process millions of transactions a month across a global client-base and add significant value to mission-critical processes.  

== The Challenge
Coming from a spring boot background with multiple microservices, we had what was a pretty standard practice: Each application had it's own codebase and a copy/paste copy of a basic gitlab-ci.  Each application would live and die on it's own throughout the entire build/test/deploy process.  Granted, the gitlab-ci script was templated, but overall, each application was different enough that it couldn't be a complete copy.  Each production deploy would update the version so ordering the projects was important: Child deploys had to wait until the parent was done since the dependencies would update and that led us to only being able to deploy a single application at a time.

This took time for each full build.  Application A would be updated, tests would be run, deploy created and released, then application B would be updated with a new version for application A, tests run for application B, deploy created.....  On a good day, it would take a couple hours to go through all application waiting for the build to complete and released.  Most of this was waiting for tests to run or the release to be created which meant it was multiple 5-10 minute long waits before the next step.  There was no one button press to do everything.  Additional was the concern that a change to application A didn't break application E down the chain.

== GitLab Setup
The setup we settled on for everything was to split services, cluster operations, and templates into individual projects.  This allows us to easily introduce changes to existing configurations or apply new ones with minimal effort and maximum flexibility.

The _cluster_ project centralizes anything that touches the kubernetes cluster into a single application. Each Quarkus service uses downstream triggers to notify the cluster project when something needs to be deployed or cleaned up.  

It is configured as a GitLab https://docs.gitlab.com/ee/user/clusters/management_project_template.html[cluster-management^] project to manage our cluster applications like elastic, nginx, or jaeger, and any additional custom Helm charts.

image::gitlab/cluster-project.png[GitLab Cluster Project,align="center",width="292"]

The _templates_ project contains the various building blocks (templates) used to support end-to-end building, testing, and deployment of Quarkus services as well as other stacks. This lets us use a single project to serve as the source for all Gitlab-ci job scripts which allows easy maintainence and flexability.  Each Quarkus service uses these defaulted template jobs resulting in each individual Quarkus services's Gitlab-ci script being very small.
  
image::gitlab/templates-project.png[GitLab Templates Project,align="center",width="292"]

=== Quarkus Services
Each service is responsible for its own Kubernetes configuration using the https://quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes^] and https://quarkus.io/guides/kubernetes-config[Quarkus Kubernetes Config^] extensions.

TIP: Templatizing the Quarkus service pipeline specifically lets you mix and match respository styles while still maintaining a consistent workflow. The templates should be flexibile enough to configure where the service resides, within a folder or at the root of a project. Done right you can invoke these pipelines in parallel and speed up the process.

TIP: Watch the service name carefully if you care overriding the Quarkus template.  It must match exactly or it will cause duplicates.

The _Platform_ project below is a Mono Repository. All of its services are contained under a `services` folder but the pipelines treat each of them as if they were a unique project.

image::gitlab/mono-repo.png[GitLab Mono Repository Project,align="center",width="292"]

TIP: When we refer to the term _Mono Repository_ we consider that a _family_ of related services. Even though they each run their own pipeline as if they were separate projects, they are versioned and managed as a single atomic unit. This make management of those services less tedious and easier to configure and document. Each of the services still adheres to the same architectural patterns as single-services do. A good example of this are our AWS services which comprise multiple stand-alone services such as S3, SQS, SNS, etc.

TIP: Lighter than a feature - Quarkus Native Builds are 1/10th the size of their equivalent Spring-Boot/Docker containers. They download and startup fast.

== Quarkus Extensions
Using Quarkus extensions, and since GitLab offers hooks for many of the them out-of-the-box, has made it easy and straight-forward to centralize the most common needs of developers in one place. 

Leveraging Quarkus extensions and integrating them into GitLab has:

- Saved time
- Increased visibility
- Fostered collaboration
- Reduced learning curves across all our teams

Two of the most important extensions we use are the https://quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes^] and https://quarkus.io/guides/kubernetes-config[Quarkus Kubernetes Config^] extension. 

Other useful extensions we integrate with GitLab are:

- https://quarkus.io/guides/tests-with-coverage[Quarkus Jacoco Extension^] provides coverage https://docs.gitlab.com/ee/ci/pipelines/settings.html#add-test-coverage-results-to-a-merge-request[results^] and https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html[reports^] for the job
- https://quarkus.io/guides/logging-sentry[Quarkus Logging Sentry Extension^] hooks into https://docs.gitlab.com/ee/operations/error_tracking.html[GitLab Error Tracking]
- https://quarkus.io/guides/smallrye-health[Quarkus SmallRye Health^] hooks into https://docs.gitlab.com/ee/operations/metrics/[GitLab Metrics^]
- https://quarkus.io/guides/openapi-swaggerui[Quarkus SmallRye OpenAPI Extension^] exposes https://docs.gitlab.com/ee/api/openapi/openapi_interactive.html[Swagger^] from within GitLab
- https://quarkus.io/guides/opentracing[Quarkus SmallRye OpenTracing Extension^] hooks into https://docs.gitlab.com/ee/operations/tracing.html[GitLab Tracing^]

In most cases, all that is needed to integrate an extensions functionality into GitLab is as simple as adding it to the project, configuring the properties, and then enabling the integration in GitLab.

TIP: Quarkus extensions are what make the whole process so powerful. Individually, they are easy enough to setup and add value to each service but, when made an integral part of an automated process, their simplicity and flexibility really start to shine.  Similar to the DevPanel you get using `quarkus:dev`, you can weave the extensions together to provide a complete picture of environments from development to deployment and more.

== Dreaming of Pipelines

=== Go With the Flow Development
An important part of rethinking our development process from the ground-up to fit better in a microservice world was how could we streamline the development process?  We never had a problem with deploying services to higher environments, albeit it being tedious, but we envisioned a process that was much more heavily developer orientated.

Using GitLab, we decided to standardize on using a https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html[merge-requests pipelines^] to drive our process in its entirety.

image::gitlab/merge-request.png[Merge Request,align="center"]

Within every merge-request we:

- Always run all the unit tests
- Run integration tests (Mongo, Redis)
- Run E2E tests (AWS, external services)
- Generate code coverage and quality reports
- Provide live interaction with that branch's Swagger API

From the merge-request developers can choose to deploy one or more services, essentially recreating the cluster specific to that feature, in complete isolation and safety. If only a few services are involved in the feature we reconfigure the deployment so that it falls back to the staging services.

image::gitlab/develop-pipeline.png[Review Pipeline,align="center"]

Two important parts of our pipeline are the downstream jobs to build Quarkus services and then deploy them.

=== Downstream Quarkus Build
The downstream Quarkus build is a unique pipeline specific to building, testing, and containerizing (only) Quarkus services. This is where we make heavy use of the Quarkus Kubernetes and Kubernetes Config extension.

When a Quarkus service is involved we:

- Build the service.
- Run any tests for the service.
- Generate the manifests for the service.
- Build and deploy the container

image::gitlab/develop-downstream.png[Service Downstream Service,align="center"]

TIP: We stop at building and deploying the container because here we take the generated Kubernetes manifests and upload them to S3 instead of deploying directly.  This lets us group any number of services in one deployable unit that can be tracked.  That unit may be a merge-request or an environment such as staging or production.

Once the container is built and the manifests are uploaded the service can be deployed at anytime (or we can easily rollback to a previous version if needed).

After any/all of the services have been build we can then deploy them to the cluster.

=== Faster, Faster, Faster Pipelines
To speed up the pipelines, especially when building multiple native services, we use GitLab AutoScaling runners and invoke the builds in parallel.  This generally allows us to build all of our services in a relatively constant time frame of about 10 minutes.

Additionally, we make use of GitLab's `needs` keyword to short-circuit the pipeline so that we can get to more important jobs when the bare minimum requirements are met.  This allows us to immediately, and repeatedly if needed, deploy services as they are ready instead of having to wait.

The DAG shows how we short-circuit longer-running jobs so that other jobs can be started quicker, further speeding up the process.

image::gitlab/develop-dag.png[Review DAG,align="center"]

In the above DAG, anytime any service is ready we can choose to deploy it.

== One Deploy to Rule Them All
Where a branch drives the development process, a tag drives the release process. Once a tag has been created, all of the steps below are completely automated up to production.

Whenever we decide to promote from the default branch, and it can happen multiple times a day, we create a release tag that is tracked and deployed into higher environments.

image::gitlab/promotion.png[Promoting a Release,align="center"]

Running the `promote` performs the following actions:

- Creates a release tag.
- Updates the changelog of the project.
- Build and deploy the selected services.
- Bump the version to the next version.

image::gitlab/release-pipeline.png[Deploy to Staging,align="center"]

After the containers are deployed we immediately deploy them to the cluster.

image::gitlab/deployment.png[Single Deployment,align="center"]

For any given cluster deployment, we update the configuration and deploy all of the affected services into the environment.

image::gitlab/cluster-downstream.png[Cluster Downstream Service,align="center"]

You can see the transitioning from a merge-request, to merging into the default branch, and finally promotion in the jobs pictured below.

image::gitlab/history.png[History of Deployments,align="center"]

== Git Your Quarkus Features
The end result of tightly integrating our GitLab process with our Quarkus-based platform is that not only has our process become greatly streamlined but, we also are able to provide a one-stop shop for most of the relevant tools, logs, and monitoring needed by all of our teams.  

This has increased overall developer productivity and made it easier to navigate what is usually a complicated and confusing landscape when building a microservice architecture.

The most significant benefit is that everything can be accessed right from GitLab...

Teams can use GitLab first instead of having to interact with different external tools and applications (except in advanced scenarios).

=== Interactive API Endpoints
Swagger can be viewed and interacted with directly in GitLab. This allows for quick and easy spot testing during development or validating endpoints post-deployment.

image::gitlab/swagger.png[Swagger API,align="center"]

=== Errors and Warnings
Sentry is hooked into each project so that specific errors and warnings can be found quickly and easily without having to dig through logs.  We can even create or resolve tickets directly from the issue.  

image::gitlab/view-sentry.png[Sentry Errors,align="center"]

=== Coverage and Quality Reports
Jacoco generates coverage reports for each project and all the services within it when branches are merged. Coverage metrics are maintained and compare throughout the lifetime of each project.

image::gitlab/coverage.png[Coverage Report,align="center"]

Additionally, Code Climate is used to show changes in quality from the default branch and each merge request throughout the life of every project.

=== Distributed Service Traces
Jaeger provides us with insights into how services are being used and gives us the ability to trace execution across multiple services.

image::gitlab/view-jaeger1.png[Jaeger Query,align="center"]
image::gitlab/view-jaeger2.png[Jaeger Details,align="center"]

This is especially important in our platform because we heavily rely on single-responsibility services that need to communicate with other services and compose functionalities.

=== Pod Health
Pod health can be monitored, per environment, by adding a couple of GitLab-specific annotations to the Quarkus generated Kubernetes manifests.

image::gitlab/view-pods.png[Pod Health,align="center"]

=== Cluster Logs
Kubernetes logs can be viewed, for any of the pods, through the cluster-managed project alleviating the need for direct access to the cluster. 

Logs can be viewed per environment or filtered for specific pods.

image::gitlab/view-logs.png[Cluster Logs,align="center"]

=== Prometheus Metrics
Prometheus metrics are exposed using GitLab's monitoring and metrics. 

image::gitlab/prom.png[Prometheus Metrics,align="center"]

We even have the ability to hook in custom Granfana dashboards.

== Conclusion


